<div align="center">
<h1><a id="intro">Лабораторная работа №2</a><br></h1>
<a href="https://docs.github.com/en"><img src="https://img.shields.io/static/v1?logo=github&logoColor=fff&label=&message=Docs&color=36393f&style=flat" alt="GitHub Docs"></a>
<a href="https://daringfireball.net/projects/markdown"><img src="https://img.shields.io/static/v1?logo=markdown&logoColor=fff&label=&message=Markdown&color=36393f&style=flat" alt="Markdown"></a> 
<a href="https://symbl.cc/en/unicode-table"><img src="https://img.shields.io/static/v1?logo=unicode&logoColor=fff&label=&message=Unicode&color=36393f&style=flat" alt="Unicode"></a> 
<a href="https://shields.io"><img src="https://img.shields.io/static/v1?logo=shieldsdotio&logoColor=fff&label=&message=Shields&color=36393f&style=flat" alt="Shields"></a>
<a href="https://img.shields.io/badge/Risk_Analyze-2448a2"><img src="https://img.shields.io/badge/Course-Risk_Analysis-2448a2" alt= "RA"></a> <img src="https://img.shields.io/badge/AppSec-2448a2" alt= "RA"></a> <img src="https://img.shields.io/badge/Contributor-Анисимов_М._А.-8b9aff" alt="Contributor Badge"></a></div>

***

## База

Давайте начнем с описания как это работает, но следует подойти к этому вопросу изначально с **терминов**, таких как: 

- **Терминал** — устройство ввода/ вывода
- **Оболочка операционной системы** `shell` — оболочка интерпретатор команд обеспечивающий интерфейс для взаимодействия пользователя с функциями ОС. В Linux стандартной оболочкой по умолчанию является bash с командами:
> - `env` – выводит список переменных окружения
> - `export` – экспортирует переменные окружения
> - `echo` – выводит что передано в качестве параметра
> - `reset` – возврат настроек терминала к значениям по умолчанию
> - `logout` – завершение сеанса
> - `exit` – завершение сеанса оболочки 

- **Консоль** — интерфей скомандной строки с командами для работы с файлами

> - `ls` – вывод содержимого каталога
> - `cd` – смена текущего каталога
> - `touch` – создание файла
> - `mkdir` – создание каталога
> - `rm` / `rmdir` - удаление файлаф
> - `cp` - копирование
> - `mv` - перенос
> - `ln` – создание ссылок на файлы
> - `cat` / `tac` – вывод содежимого файла
> - `df` - отчёт об использовании дискового пространства
> - `du` - отчёт об используемом месте на диске
> - `wc` – подсчет размера, числа, символов и тд.
> - `uniq` – нахождение дублирующихся строк
> - `grep` – поиск пошаблону

- **Файловая система**, которая представляет собой пути каталогов к файлам с определенными правами для пользователей

> - `/bin` – исполняемые файлы, которые содержат исполняемые программы и скрипты
> - `/sbin` – исполяемые файлы и системное ПО
> - `/dev` – файлы устройств
> - `/etc` – файлы конфигурации, который является централизованным хранилищем настроек системы и приложений. Если не предполагает иметь более одного конфига, то располагается непосредственно в нем, в другом случае создает каталог для размещения
> - `/lib` – системные библиотеки
> - `/home` – каталоги пользователей
> - `/root` – каталог суперпользователя
> - `/usr` – размещение приложений
> - `/var` – данные приложений 
> - `/tmp` – временный каталог системы
> - `/var/tmp` – временные каталоги приложений
> - `/proc` – файловый интерфейс ОС
> - `/mnt` – монтирование сетевых ФС
> - `/media` – монтирование съемных ФС
> - `/boot` – загрузчики ядра системы
> - `/sys` – интерфейс устройства ОС

- Для ОС *nix используются следующие **переменные окружения:**

> - `SHELL` – путь текущего пользователя
> - `USER` – пользователь
> - `HOME` – домашний каталог пользователя
> - `PATH` – содержит пути для поиска файлов по умолчанию
> - `PWD` – указывает на текущий каталог
> - `LANG` – определяет текущие настройки локали

***

## Права доступа

При монтировании образа для каждой *nix ОС задаются права доступа к файлам и путям каталогов, которые позволяют их индивидуально профилировать, а также изменять, но давайте посмотрим на общую картину, советую ознакомиться изначально с Петром Девянином и его описанием `take-grant` [модели](https://academia-moscow.ru/ftp_share/_books/fragments/fragment_20276.pdf). Система безопасности построена на:

> - chmod — изменение прав доступа

```bash
$ chmod [-R] [option] [rules] # пользователь может менять только у принадлежащих ему файлов, а root у всех файлов в системе
```

> - umask — маска прав доступа
дляполученияреальныхправвновь
. 
> - chown — изменение владельца

```bash
$ chown [-R] user[:group] file # доступна только для root
         -R # рекурсивная смена
```

> - chgrp — изменение группы

```bash
$ chgrp [-R] group ... file # изменение группы файла для пользователя только там, где он является ее членом
```

У каждого файла или каталога имеются определенные права доступа, такие как:

> - r — право на чтение из файла / просмотр содержимого директории
> - w — право на запись в файл / создание, удаление файлов в директории
> - x — право на исполнение / доступ в директорию и сабдиректории

По умолчанию права для директории **777**, а для файлов **666**. А теперь давайте посмотрим, как можно поменять права. На сейчас все `*nix` поддерживают `POSIX ACL`, который позволяет указать права доступа для конкретных пользователей и групп.

```bash
$ getfacl [option] file ... # показывает список access list
$ setfacl [option] file ... # устанавливает или удаляет access list
         -m # изменение или установка
         -х # удаление
         
# Пример
$ setfacl -m u:user1:rw file # для пользователя
$ setfacl -m g:users:r file # для группы
$ setfacl -m m::rw file для # маски

```
 
***

## Процессы

А теперь давай посмотрим, что каждому выполняемому процессу присваивается уникальный номер `PID` Process ID, где его ID после завершения процесса высвобождается. У всех процессов в системе кроме самого первого (**PID = 1** - `init`) есть родительские, которые запускают процесс. 

```bash
$ ps [option] # список процессо в всистеме
    -a # список всех процессов привязанных к терминалу
    -x # ... не привязанных к терминалу
    —е # показывает все процессы системы
    -f # показывает дерево процессов
    -u user # список процессов пользователя
$ pstree # дерево процессов

$ kill [-l] PID # пример как можно вывести спиок всех сигналов
$ killall [-signal] # определение процесса по имени
```

После завершения работы родительского процесса у наследователя становится init. Также, если `shell` заканчивает работу, то все процессы будут завершены. Но если надо, что бы программа работала далее без оболочки, то ее необходимо запускать при помощи `nohup`, так как отключает программу от терминала. А теперь, все вы знаете про `daemon`, а это именно то, что работает после запуска и сразу же отключается от терминала.

***

## Задание

- ✅ 1. Выведите на терминале и проанализируйте следующие команды консоли

```bash
$ who | wc -I
$ id
$ whoami
$ hostnamectl
```

- ✅ 2. Выведите утилитой `tree` список вложенности дерева диреторий для каталога своего пользователя. Далее используйте `ls -a` и укажите отличие от `ls -l`.
- ✅ 3. Используйте утилиту `file` и `df` для определения какая файловая система на разделе `/dev/sda1`.
- ✅ 4. Выведите на терминале и проанализируйте следующие команды консоли

```bash
$ which vi
$ locate hello.py
$ sudo updatedb
$ locate hello
$ touch screen
$ find ~ -name screen
$ locate screen
$ sudo updated
$ locate screen
```

- ✅  5. Используйте конструкцию и вставьте ее в созданный файл ранее. Подключите `pygame` - используем исключительно для стилизации окна.

```py
import pygame
pygame.init()

# Устанавливаем размеры окна
screen_width = 800
screen_height = 600
window_size = (screen_width, screen_height)
pygame.display.set_mode(window_size) # Создаем окно

# Задаем цвет фона
bg_color = (255, 255, 255)
pygame.draw.rect(screen, bg_color, [0, 0, screen_width, screen_height], 1)

# Выводим текст на экран
font = pygame.font.SysFont(None, 75)
text = font.render("Hello appsec world*", True, (0, 255, 0))
text_rect = text.get_rect()
text_rect.center = (400, 300)
screen.blit(text, text_rect)

while True:
    for event in pygame.event.get():
        if event.type == pygame.QUIT:
            pygame.quit()
            quit()
pygame.display.flip() # Обновляем экран
```

- ✅ 6. Сделайте `commit` и `push` в свой репозиторий с изменениями в `master branch`. На следующих лабораторных работах мы вернемся к этому файлу.
- ✅ 7. Выведите на терминале и проанализируйте следующие команды консоли

```bash
$ groups
$ useradd smallman
$ userdel smallman -rf
$ useradd smallman
$ passwd smallman
$ usermod smallman -c 'Hach Hachov Hacherovich,239,45-67,499-239-45-33'
$ passwd smallman
$ id smallman
$ groupadd -g 1500 readgroup
$ usermod -aG readgroup smallman
$ chmod 666 screen 
```


- ✅ 8. Выведите группу прав для `screen` и измените, что бы файл был доступен только для чтения созданному пользователю и выведите права этого польователя для измененного файла только используя `readgroup`.
- ✅ 9. Используйте `POSIX ACL`. Выведите на терминале и проанализируйте следующие команды консоли

```bash
$ touch nmapres.txt
$ setfacl -m u:smallman:rw nmapres.txt
$ setfacl -m g:readgroup:r nmapres.txt
$ getfacl nmapres.txt
```

- ✅ 10. Сохраните файл внутри локального репозитория, так как следующая работа будет подразумевать запись в нее данных о nmap.
- ✅ 11. Для закрепления выведите все списки групп пользователей на вашей ОС и права на верхнеуровневые каталоги.
- ✅ 12. Выведите все права для файлов и директорий локального репозитория которые имеют различные пользователи  (без использования длинных путей)
- ✅ 13. Выведите процессы которые у вас запущены в термине и вне его.
- ✅ 14. Оформить `README.md` по аналогии и использовать `shield`, etc.
- ✅ 15. Составить `gist` отчет и отправить ссылку личным сообщением

***

Copyright (c) 2025 Maksim Anisimov
